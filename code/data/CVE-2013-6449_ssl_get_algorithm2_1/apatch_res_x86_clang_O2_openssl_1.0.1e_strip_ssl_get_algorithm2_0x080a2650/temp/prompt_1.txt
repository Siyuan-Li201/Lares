Suppose you are a software reverse engineer with strong code analysis skills. You have the source code of a function and the pseudo code obtained through binary decompilation. The variable name information in the Pseudo code is lost. Lines in the source code that end with "    // patch_code" are patch codes. Some patch codes contain macro definitions in comments. Lines in the source code that end with "    // locate_code" are locate codes. Can you identify the patch codes and locate codes in the pseudo code that corresponds to the patch code? Must only output your findings as a JSON dictionary. Keep the comments (like " // 2") in the matched pseudocode.

output format:
{
    "new match result":{
        "a line of patch code": ["coresponding code1 in pseudo code", "coresponding code2 in pseudo code", ...],
        more result...
    },
    "corresponding pseudo code": "must output the unchanged original corresponding lines in pseudo code here"
}

source code:
// Function starts at line 4286
long ssl_get_algorithm2(SSL *s)  //patch_code
	{
	long alg2 = s->s3->tmp.new_cipher->algorithm2;
	if (s->method->version == TLS1_2_VERSION &&  //patch_code
	    alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))  //patch_code
		return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;  //patch_code
	return alg2;  //patch_code
	}

pseudo code:
int __cdecl sub_80A2650(int *a1) // 1
{ // 2
  int result; // eax // 3
 // 4
  result = 131200; // 5
  if ( (*a1 & 0xFFFFFF00) != 768 ) // 6
    result = *(_DWORD *)(*(_DWORD *)(a1[22] + 836) + 36); // 7
  if ( *a1 <= 770 ) // 8
    result = *(_DWORD *)(*(_DWORD *)(a1[22] + 836) + 36); // 9
  if ( *(_DWORD *)(*(_DWORD *)(a1[22] + 836) + 36) != 49200 ) // 10
    result = *(_DWORD *)(*(_DWORD *)(a1[22] + 836) + 36); // 11
  return result; // 12
} // 13
