Suppose you are a software reverse engineer with strong code analysis skills. You have the source code of a function and the pseudo code obtained through binary decompilation. The variable name information in the Pseudo code is lost. Lines in the source code that end with "    // patch_code" are patch codes. Some patch codes contain macro definitions in comments. Lines in the source code that end with "    // locate_code" are locate codes. Can you identify the patch codes and locate codes in the pseudo code that corresponds to the patch code? Must only output your findings as a JSON dictionary. Keep the comments (like " // 2") in the matched pseudocode.

output format:
{
    "new match result":{
        "a line of patch code": ["coresponding code1 in pseudo code", "coresponding code2 in pseudo code", ...],
        more result...
    },
    "corresponding pseudo code": "must output the unchanged original corresponding lines in pseudo code here"
}

source code:
// Function starts at line 4286
long ssl_get_algorithm2(SSL *s)  //patch_code
	{
	long alg2 = s->s3->tmp.new_cipher->algorithm2;
	if (TLS1_get_version(s) >= TLS1_2_VERSION &&  //patch_code
	    alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))  //patch_code
		return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;  //patch_code
	return alg2;  //patch_code
	}

pseudo code:
int __cdecl sub_80E7180(int *a1) // 1
{ // 2
  int v2; // [esp+0h] [ebp-10h] // 3
  int v3; // [esp+Ch] [ebp-4h] // 4
 // 5
  if ( *a1 >> 8 == 3 ) // 6
    v2 = *a1; // 7
  else // 8
    v2 = 0; // 9
  if ( v2 >= 771 && *(_DWORD *)(*(_DWORD *)(a1[22] + 836) + 36) == 49200 ) // 10
    v3 = 131200; // 11
  else // 12
    v3 = *(_DWORD *)(*(_DWORD *)(a1[22] + 836) + 36); // 13
  return v3; // 14
} // 15
