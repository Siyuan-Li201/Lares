 I'll analyze the source code and pseudo code to identify the correspondences between patch codes and the decompiled pseudo code.
> 🔍 ***SSL TLS1_get_version TLS1_2_VERSION constants***

> 🔗 [/docs/man1.1.1/man3/](https://www.openssl.org/docs/man1.1.1/man3/SSL_SESSION_set_protocol_version.html)
> 🔗 [How to know which ve](https://learn.microsoft.com/en-us/answers/questions/1006253/how-to-know-which-versions-of-tls-is-are-enabled-o)
> 🔗 [How to check and/or ](https://support.networkoptix.com/hc/en-us/articles/17314112665111-How-to-check-and-or-change-the-TLS-version)
> 🔗 [java - Will SSLConte](https://stackoverflow.com/questions/29841610/will-sslcontext-getinstancetls-supports-tls-v1-1-and-tls-v1-2-also)
> 🔗 [SSL and TLS Protocol](https://wiki.openssl.org/index.php/SSL_and_TLS_Protocols)
> 🔗 [Transport Layer Secu](https://en.wikipedia.org/wiki/Transport_Layer_Security)
> 🔗 [TLS Checker: How to ](https://cheapsslsecurity.com/blog/tls-checker-how-to-check-the-tls-version-of-a-website/)
> 🔗 [Protocols in TLS/SSL](https://learn.microsoft.com/en-us/windows/win32/secauthn/protocols-in-tls-ssl--schannel-ssp-)
> 🔗 [linux - How can I ve](https://serverfault.com/questions/638691/how-can-i-verify-if-tls-1-2-is-supported-on-a-remote-web-server-from-the-rhel-ce)
> 🔗 [Check supported TLS ](https://blog.toshima.ru/2020/01/06/check-supported-tls-version.html)



After analyzing the source code and pseudo code, I can identify the correspondences between the patch codes in the source code and their equivalent lines in the decompiled pseudo code.

Based on my analysis, here's the mapping:

```json
{
    "new match result":{
        "long ssl_get_algorithm2(SSL *s)  //patch_code": ["int __cdecl sub_80E7180(int *a1) // 1"],
        "if (TLS1_get_version(s) >= TLS1_2_VERSION &&  //patch_code": ["if ( v2 >= 771 && *(_DWORD *)(*(_DWORD *)(a1[22] + 836) + 36) == 49200 ) // 10"],
        "alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))  //patch_code": ["*(_DWORD *)(*(_DWORD *)(a1[22] + 836) + 36) == 49200 ) // 10"],
        "return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;  //patch_code": ["v3 = 131200; // 11"],
        "return alg2;  //patch_code": ["return v3; // 14"]
    },
    "corresponding pseudo code": "int __cdecl sub_80E7180(int *a1) // 1\n{ // 2\n  int v2; // [esp+0h] [ebp-10h] // 3\n  int v3; // [esp+Ch] [ebp-4h] // 4\n // 5\n  if ( *a1 >> 8 == 3 ) // 6\n    v2 = *a1; // 7\n  else // 8\n    v2 = 0; // 9\n  if ( v2 >= 771 && *(_DWORD *)(*(_DWORD *)(a1[22] + 836) + 36) == 49200 ) // 10\n    v3 = 131200; // 11\n  else // 12\n    v3 = *(_DWORD *)(*(_DWORD *)(a1[22] + 836) + 36); // 13\n  return v3; // 14\n} // 15"
}
```

The analysis is based on the following observations:

1. The function signature `long ssl_get_algorithm2(SSL *s)` corresponds to `int __cdecl sub_80E7180(int *a1)` in the pseudo code.

2. The condition `if (TLS1_get_version(s) >= TLS1_2_VERSION &&` corresponds to `if ( v2 >= 771 &&` in the pseudo code. Based on the search results, 771 appears to be the value for TLS1_2_VERSION in this context.

3. The condition `alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))` corresponds to `*(_DWORD *)(*(_DWORD *)(a1[22] + 836) + 36) == 49200 )` where 49200 is the value for SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF.

4. The return statement `return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;` corresponds to `v3 = 131200;` where 131200 is the value for SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256.

5. The final return statement `return alg2;` corresponds to `return v3;` in the pseudo code.