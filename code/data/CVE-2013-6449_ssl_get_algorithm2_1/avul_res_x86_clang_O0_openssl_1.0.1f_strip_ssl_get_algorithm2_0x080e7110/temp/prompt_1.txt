Suppose you are a software reverse engineer with strong code analysis skills. You have the source code of a function and the pseudo code obtained through binary decompilation. The variable name information in the Pseudo code is lost. Lines in the source code that end with "    // patch_code" are patch codes. Some patch codes contain macro definitions in comments. Lines in the source code that end with "    // locate_code" are locate codes. Can you identify the patch codes and locate codes in the pseudo code that corresponds to the patch code? Must only output your findings as a JSON dictionary. Keep the comments (like " // 2") in the matched pseudocode.

output format:
{
    "new match result":{
        "a line of patch code": ["coresponding code1 in pseudo code", "coresponding code2 in pseudo code", ...],
        more result...
    },
    "corresponding pseudo code": "must output the unchanged original corresponding lines in pseudo code here"
}

source code:
// Function starts at line 4286
long ssl_get_algorithm2(SSL *s)  //patch_code
	{
	long alg2 = s->s3->tmp.new_cipher->algorithm2;
	if (TLS1_get_version(s) >= TLS1_2_VERSION &&  //patch_code
	    alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))  //patch_code
		return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;  //patch_code
	return alg2;  //patch_code
	}

pseudo code:
int __cdecl sub_80E7110(int a1) // 1
{ // 2
  int v2; // [esp+8h] [ebp-4h] // 3
 // 4
  if ( **(_DWORD **)(a1 + 8) == 771 && *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 88) + 836) + 36) == 49200 ) // 5
    v2 = 131200; // 6
  else // 7
    v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 88) + 836) + 36); // 8
  return v2; // 9
} // 10
